---
jupyter:
  jupytext:
    formats: ipynb,md,Rmd
    text_representation:
      extension: .Rmd
      format_name: rmarkdown
      format_version: '1.2'
      jupytext_version: 1.7.1
  kernelspec:
    display_name: Python 3
    language: python
    name: python3
---

```{python}
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from IPython.display import display
import re

csvPath = "timers_Gpipe_producer_QS12800_Req100_Run12_Thread128_MS50.csv"

def path2info(path):
    for w in re.split('_|\.', path):
        if w.startswith('QS'):
            queueSize = int(w[2:])
        if w.startswith('Req'):
            reqsCount = int(w[3:])
        if w.startswith('Run'):
            runsCount = int(w[3:])
        if w.startswith('Thread'):
            threadCount = int(w[6:])
        if w.startswith('MS'):
            messageCount = int(w[2:])            
    
    return queueSize, reqsCount, runsCount, threadCount, messageCount

queueSize, reqsCount, runsCount, threadCount, messageCount = path2info(csvPath)

print("CSV file info:")
print(f"queue_size = {queueSize}")
print(f"reqsCount = {reqsCount}")
print(f"runsCount = {runsCount}")
print(f"threadCount = {threadCount}")
print(f"messageSize = {messageCount}")

data = pd.read_csv(csvPath).dropna(how='all', axis='columns')
```

```{python}
minMsIdx = 0
maxMsIdx = 6
```

```{python}
def title2messege_count(title):
    return re.findall(r"\[(\d+)\]",title)[0]

# Latency -> Throughput -> Latency -> Throughput
message_counts = [title2messege_count(t) for t in data.columns[::]]
print(message_counts)
#print(list(zip(list(range(len(message_counts))),message_counts)))

precentiles = [0.99,0.9, 'avarage']
iles_titles = [str(p) for p in precentiles]

def find_percentiles(df):
    columnsCount = df.shape[1]
    data_throughput_std = []
    data_latency_std = []
    res_columns = []
    
    for columnIdx in range(0,columnsCount):
        runResultsLatency = np.array(df.iloc[1:,columnIdx])
        current_message_count = message_counts[columnIdx]
        runResults_sorted = runResults.sort()
        
        precentile_run_res = []
        
        for p_idx, p in enumerate(precentiles):
            
            if p == 'avarage':
                precentile_run_res.append(runResults.mean())
                
                lat_std = runResults.std()
                throughput_std.append(tp_std)
                
                latency_std.append(lat_std)
                                
            else:
                row_idx = int(rows_count*p)-1
                column_res.append(trail_sorted.iloc[row_idx,:])
                
        res_columns.append(pd.concat(res_rows, axis=1).transpose().set_index(pd.Index(iles_titles)))
    return pd.concat(res_columns, axis =1)


def calc_throughput(latency):
    
    for run in range(0, runsCount):
        
        for req in range(0, reqsCount):
    
    
    
data_latency = data.iloc(1:,:)
data_throughput = 


data_res = find_percentiles(data)
    
def plot_valVSms(ax, val, std, ms, label,):
    ms = np.array(ms)
    tp = np.array(val)
    ax.scatter(ms, val, label=label)
    if (std != None):
        ax.errorbar(ms, val, yerr=std)
    else: 
        ax.plot(ms,val) 

def plot_res(res_df, tp_std, lat_std, title, queue_size):
    res_df = res_df.iloc[:,minMsIdx*2:maxMsIdx*2+2]
    tp_std = tp_std[minMsIdx:maxMsIdx+1]
    lat_std = lat_std[minMsIdx:maxMsIdx+1]
    ms = message_counts[minMsIdx:maxMsIdx+1]
    
    fig, axs = plt.subplots(nrows=2, ncols=1, figsize=(15,10), sharex='col')
    plt.subplots_adjust(hspace=0.1)
    fig.suptitle(f"{title} - buffer size {queue_size} [bytes]")
    
    tp_min = np.inf
    tp_max = 0
    
    for i in range(res_df.shape[0]):
        ile_tp_std, ile_lat_std = [tp_std, lat_std] if (iles_titles[i] == 'avarage') else [None, None]     
        plot_valVSms(axs[0], res_df.iloc[i,0::2], ile_lat_std, ms, iles_titles[i])
        axs[0].set_xlabel("message count")
        axs[0].set_ylabel("latency [clock cycle]")
        plot_valVSms(axs[1], res_df.iloc[i,1::2], ile_tp_std, ms, iles_titles[i])
        axs[1].set_xlabel("message size [bytes]")
        axs[1].set_ylabel("throughput [bytes / clock cycle]")
        tmp = np.min(np.array(res_df.iloc[i,1::2]))
        print(f"tmp={tmp}")
        min = np.min([tp_min, tmp])
        max = np.max([tp_max, np.max(np.array(res_df.iloc[i,1::2]))])
        
    #if (queue_size < message_counts[maxMsIdx]):
        #axs[0].axvline(queue_size, label="buffer size", color="red")
        #axs[1].axvline(queue_size, label="buffer size", color="red")
    axs[0].legend()
    axs[1].legend()
    
    axs[1].set_ylim(tp_min,tp_max)
    
plot_res(data_res, data_throughput_std, data_latency_std, csvPath_prod, queue_size)
data_res
```

```{python}

```
